%=======================================================================
\chapter{Multi-paradigm programming in Prolog and .NET}
\label{ch:mpp-in-dotnet}
%=======================================================================

\tuprolog{}.NET now provides the user with the same features as the Java version, extending and specializing the multi-paradigm, multi-language experience to the plethora of languages available onto the Microsoft .NET platform.
In this Chapter, the impact of such change is discussed, both in terms of specific conceptual concepts (namely, \textit{language conventions} to handle multiple languages) and new/specialized libraries and predicates to be used for language interaction.

Since the current status of \tuprolog{}.NET depends \textit{a)} on its past history and \textit{b)} on the IKVM tool \cite{ik}, the two following Sections summarize its evolution from version 2.1 and the basics of IKVM translation, respectively.

While their reading is recommended to everyone, the reader wishing only to exploit \tuprolog{}.NET in its current version can safely bypass them and jump directly yo Section \ref{sec:dotnet-basics}.

%-----------------------------------------------------------------------
\section{A bit of history}
\label{sec:dotnet-tuprolog-history}
%-----------------------------------------------------------------------

%--------------------------------------------
\subsection{\tuprolog{} 2.1 and CSharpLibrary}
\label{ssec:dotnet-tuprolog2.1}
%--------------------------------------------

\tuprolog{}.NET appeared as a usable tool for the first time in April 2007, with the .NET conversion of \tuprolog{} 2.1; an earlier, experimental version had been made with version 2.0, but was never officially published.

tuProlog.NET 2.1 run on Microsoft .NET 2.0 and on Mono 1.2.5\footnote{The MONO version required a source tuning for the \texttt{TheoryManager.find} method.}, and was a complete rewriting in C\# of the original Java code: the executable became a .NET \texttt{exe} file, and all the libraries became .NET \texttt{dll} assemblies.

The Java-based, key feature to multi-paradigm-programming, \textit{JavaLibrary}, was replaced by a corresponding \textit{CSharpLibrary}, which provided the very same features, except for a few syntactic changes:
\begin{itemize}
  \item any \texttt{java\_\textit{xxx}} predicate was renamed as \texttt{csharp\_\textit{xxx}}.

  \item C\# objects defined in other namespaces than \texttt{System} required that the new namespace be explicitly passed to the predicate creating the object: so, \texttt{java\_object/3} became \texttt{csharp\_object/4}:\\
        \texttt{csharp\_object(\textit{\textbf{AssemblyName}}, \textit{ClassName}, \textit{ArgumentList}, \textit{ObjRef})}\\
      Moreover, the assembly containing the definition of the object type must be in the same folder as the \texttt{alice-tuProlog.dll} file.

\item an \textit{ad hoc} predicate was added for array creation, instead of using the standard \texttt{csharp\_object/3}-\texttt{/4} resulting from the direct conversion of JavaLibrary predicates:
    \texttt{csharp\_array(\textit{AssemblyName}, \textit{Type}, \textit{Length}, \textit{ObjRef})}
\end{itemize}

An annoying limitation concerned the loading of user-defined libraries (and theories), which had to be in the same folder as the \tuprolog{} (\texttt{IDE.exe} or \texttt{CUIConsole.exe}) executable.

From the developers' viewpoint, using \tuprolog{} classes in a Visual Studio project required a reference to the \texttt{alice-tuProlog.dll} assembly be added to the project, and the \texttt{tuProlog} namespace be imported in the usual C\# fashion (e.g. \texttt{using tuProlog;}).

%--------------------------------------------
\subsection{\tuprolog{} 2.1.3: CSharpLibrary + exceptions}
\label{ssec:dotnet-tuprolog2.1.3}
%--------------------------------------------

As a further step towards the convergence of the .NET and Java versions, the ``\tuprolog{} 3'' project --later renamed as 2.1.3 -- was started to add the exceptions support, being developed for the Java version, to the .NET version, too.
However, this version was never officially released, because of the quasi-simultaneous
development of \tuprolog{} 2.2, whose \textit{CLILibrary} could provide a much larger interest from the multi-paradigm, multi-language viewpoint.

%--------------------------------------------
\subsection{\tuprolog{} 2.2 and CLILibrary}
\label{ssec:dotnet-tuprolog2.2}
%--------------------------------------------

Version 2.2\footnote{%
    Unfortunately, version numbering for .NET was incoherent with the Java version at that time: in Java, 2.2 was the version that introduced the exception support, which was absent in 2.2 for .NET because the development \tuprolog{} 2.1.3, where exceptions were being added, occurred quasi-simultaneously, but not in time for the two projects to converge. In addition, this version was never tested on Mono.
} was a milestone in \tuprolog{}.NET history, as it generalized \textit{CSharpLibrary} to enable multi-language programming with \textit{virtually any language available on the .NET platform}, rather than C\# only (unfortunately, it lacked exception support, due to the race between the two quasi-simultaneous projects).

To this end, the concept of \textit{Language Convention} was introduced to encapsulate the language-specific aspects, so that a single library -- renamed \textit{CLILibrary} instead of \textit{CSharpLibrary} -- could handle any language.
%
Each convention contains the syntax conversion operations and the post-compilation transformations required for a given language.
Conventions were developed for C\#, J\#, VisualBasic.NET, F\#, Eiffel.NET and
IronPythonStudio.

Following the generalization renaming of \textit{CSharpLibrary} as \textit{CLILibrary}, a few syntactic changes were also made:
\begin{itemize}
  \item any \texttt{csharp\_\textit{xxx}} predicate of CSharpLibrary was renamed here as \texttt{cli\_\textit{xxx}}; this applies both to predicates derived from the JavaLibrary (of the form \texttt{java\_\textit{xxx}}) and to predicates added by CSharpLibrary, like \texttt{csharp\_array/4};

 \item to create objects bound to a particular \textit{Convention}, the \texttt{cli\_object/5} predicate was introduced whose first argument specifies the convention to be used:\\
     \texttt{cli\_object(\textit{\textbf{Convention}}, \textit{AssemblyName}, \textit{ClassName},\\
     \mbox{~~~~~~~~~~~}\textit{ArgumentList}, \textit{ObjRef})}

 \item furthermore, for those .NET programming languages whose constructor function is not constrained to coincide with the class name, and therefore require such a name to be explicitly specified on object creation, the \texttt{cli\_object/6} predicate was introduced:\\
     \texttt{cli\_object(\textit{Convention}, \textit{AssemblyName}, \textit{ClassName},\\
     \mbox{~~~~~~~~~~~}\textbf{\textit{ContructorName}}, \textit{ArgumentList}, \textit{ObjRef})}

 \item two convention handling predicates, also usable as directives, were introduces to load/unload conventions to/from a Prolog theory:\\
     \texttt{load\_convention(\textit{Assembly}, \textit{ConventionName}, \textit{ConventionAtom})}\\
     \texttt{unload\_convention(\textit{ConventionAtom})}.
\end{itemize}

From the developers' viewpoint, the new aspect is how to define new conventions: this is done by starting a new project (class library), importing the \texttt{alice-tuprolog.dll} reference and implement a new class extending \texttt{tuProlog.Convention} in the \texttt{tuProlog.Conventions} namespace.

The \texttt{dll} generated by the compilation must then be moved to the main project compiling folder.


%--------------------------------------------
\section{IKVM Basics}
\label{sec:dotnet-ikvm}
%--------------------------------------------

IKVM.NET \cite{ikvm} is basically a .NET implementation of Java (language, infrastructure, tools) enriched with special tools for Java/.NET conversion.
Its distribution, which adheres to the \textit{zlib} open source license, includes:
\begin{itemize}
  \item a .NET implementation of a Java Virtual Machine;
  \item a Java class library, based on OpenJDK, re-implemented in .NET;
  \item tools for Java/.NET inter-operability---in particular, the \texttt{ikvmc} bytecode translator that converts Java bytecode to Microsoft .NET Common Intermediate Language (CIL).
\end{itemize}

\noindent Both Microsoft .NET 2.0 and Mono platforms 2.0 are supported, both for \textit{x86} and \textit{x64} architectures. If necessary, the source pack is also available.

Debugging is also very well supported: if the Java sources are available, proper information can be generated\footnote{The option must be specified to generate the \texttt{pdb} (\textit{Program Debug Database}) file, to be copied to the application folder in Visual Studio.} that enable Microsoft Visual Studio to keep the .NET and and Java sources in sync, following the program execution on the Java source, too, as well as enabling breakpoints, variable inspection, etc.

%--------------------------------------
\subsection{Dynamic vs. Static modality}
\label{ssec:ikvm-dynamic-static}
%--------------------------------------

IKVM can work in two modalities. In the \textit{dynamic} modality, Java applications are converted in .NET on-the-fly and immediately executed; in the \textit{static} modality, instead, Java applications (or libraries) are translated into a .NET assembly, to be used to develop a .NET native application.

The dynamic modality is supported by the \texttt{ikvm} tool, which is analogous to Java's \texttt{java} interpreter\footnote{Most command line options work identically with both tools.}: so, a Java application can be executed in .NET as in would be in a Java-enabled machine, just replacing \texttt{java} with \texttt{ikvm}, in a totally user-transparent way.
Quite notably, the class loading mechanisms in this modality behaves exactly as in Java, with the same class path options.
The only drawback is performance, which is obviously penalized by the on-the-fly translation.

The static modality is supported by the \texttt{ikvmc} tool, which generates a \texttt{dll} or \texttt{exe} .NET assembly (depending whether the translation concerns a Java library or application, respectively) converting Java types to .NET types.
Obviously, this tool has no Java counterpart: its options control the target architecture (\textit{x86} or \textit{x64}), the kind of output (\texttt{dll}/\texttt{exe}), etc.
Unlike the previous case, here the Java class loading mechanisms has some limitations, that are discussed below.
One possible drawback is IKVM choice of translating the Java \textit{package} visibility into .NET \textit{internal}'s, making it impossible to access such properties and methods from other assemblies (even though they were accessible in the Java architecture).

%--------------------------------------
\subsection{Class loading issues}
\label{ssec:ikvm-class-loading}
%--------------------------------------

The class loading mechanism is perhaps the major issue when translating Java applications to .NET, because of the very different approach adopted by the two architectures, which makes it difficult to define a general mapping. In fact,
\begin{itemize}
  \item the Java approach is based on the \textit{class path} concept, which defines the set of paths where classes must be looked for;
  \item the .NET approach, instead, exploits the current folder, the Global Assembly Cache (GAC) and configuration files for the same purpose.
\end{itemize}

\noindent In order to bridge this gap, IKVM adopts the following intelligent approach:
\begin{itemize}
  \item each \textit{statically-generated} assembly is associated to its own class loader---either a user-supplied one, or the default one;

  \item the default class loader looks for classes:
  \begin{enumerate}
    \item first, in the assembly itself;
    \item then, in all the assemblies \textit{directly referenced} by the former.
  \end{enumerate}
\end{itemize}

\noindent This approach guarantees that classes are always found \textit{if all dependencies are statically expressed}, i.e. if all the libraries used by an application are statically known, and their references are added in the application project.
Problems are to be expected, instead, for dynamically loaded classes, whose references were not included in the project---and whose assemblies, therefore, are not considered by the class loader.

To overcome this issue, four alternatives can be followed:
\begin{enumerate}
  \item creating a \textit{single assembly}, if size is not a problem and run-time modularity is irrelevant (that is, loading all modules even when just one is actually used is irrelevant);
  \item adding a static reference (\texttt{-r} option) to the library to be dynamically loaded, when the application is translated to .NET: then, the default .NET loading will locate the library, but the need to specify all its details (including version number) cancels most of the advantage of dynamic loading, since any change in the library to be loaded still requires a rebuild;
  \item using the special \texttt{ikvm.runtime.AppDomainAssemblyClassLoader}
  class loader provided by IKVM;
  \item writing an ad-hoc class loader, typically extending \texttt{URLClassLoader}: this is perhaps the most flexible, but also the user-heaviest, solution.
\end{enumerate}

\noindent One further interesting aspect is that the IKVM implementation of Java's \texttt{Class.forName} method adopts a more general behavior than Java's default implementation, supporting the dynamic loading of classes also \textit{beyond} the current assembly, provided that their \texttt{AssemblyQualifiedName} is specified; otherwise, only the current assembly is checked, as in Java.

So, a Java application that exploited \texttt{Class.forName} for dynamic class loading, that could originally load only classes in the application JAR, will be able to load .NET\footnote{The reason why this feature is limited to .NET classes is, trivially, that only .NET classes possess the \texttt{AssemblyQualifiedName} property and the other assembly details (version, culture, public key token).} classes beyond the application's own assembly when translated to .NET via IKVM.

%--------------------------------------
\subsection{The other way: writing .NET applications in Java}
\label{ssec:ikvm-writing-app-in-java}
%--------------------------------------

Beyond converting Java applications in .NET, IKVM also supports the opposite direction---that is, writing .NET applications \textit{in Java}, as if this were one of .NET-supported languages.

This feature is provided by the \texttt{ikvmstub} tool, which generates a Java JAR archive from a .NET assembly (\texttt{dll}/\texttt{exe}).
As the tool name suggests, the generated JAR is just a stub, containing all the Java classes and interfaces corresponding to the .NET originals, but no actual implementation, since this will be written directly in Java: its purpose is just to satisfy the \texttt{javac} compiler's type checking, and enable the code completion feature on the IDE (e.g. Eclipse) used for the Java application development.

In this way, a Java application can be written (in Java---using Eclipse, Netbeans, etc.)) that exploits the .NET types extracted from the .NET original assemblies.
This application can be compiled with \texttt{javac} as usual, specifying the above stub JAR in the class path (\texttt{-cp} option).

Obviously, such an application can \textit{not} be run in Java with the standard \texttt{java} interpreter, as the above stub JAR does not contain any actual implementation---nor would that be reasonable, since the goal was to exploit Java to write a .NET application, not a Java one.
%
Instead, the resulting ``fake'' Java application is to be translated via \texttt{ikvmc}, and then executed \textit{in .NET} where the original assemblies provide the ``missing'' classes.

\medskip

In this context, .NET concepts are mapped onto suitable Java concepts by \texttt{ikvmc} as follows:
\begin{itemize}
  \item \textit{namespaces} are mapped onto Java packages, pre-pending the \texttt{cli.} prefix to prevent name clashes;
  \item \textit{properties} are mapped onto a pair of Java \texttt{\textit{get}}/\texttt{\textit{set}} methods;
    \color{red}
  \item \textit{enumerations} \textbf{were} mapped onto classes extending \texttt{cli.System.Enum}, with static fields with integer values for each possible value of the .NET enumerative type; \textbf{still true? or using Java Enums now?}
    \normalcolor
  \item \textit{delegates} are mapped onto a Java class and a nested helper \texttt{Method} interface: the class derives from \texttt{System.MulticasDelegate} and has the same name as the original delegate, while the nested interface always declares an \texttt{Invoke} method whose signature matches the delegate: this is method called when an event occurs. For this reason, the class constructor takes as its argument an object implementing the \texttt{Method} interface, whose implementation of \texttt{Invoke} does the actual job.
  \item \textit{events} are mapped onto a pair of Java \texttt{\textit{add\_*}}/\texttt{\textit{remove\_*}} methods, whose argument is an object of the class representing the delegate;
  \item \textit{params} is mapped onto an array of \texttt{Object}s;
    \\\color{red}\textbf{maybe now using generics?}\normalcolor
  \item \textit{attributes} are mapped onto a Java class with the same name as the .NET attribute, plus a pair of Java \texttt{\textit{get}}/\texttt{\textit{set}} methods for each property defined by the attribute.\footnote{The java class also includes a nested Java annotation, called \texttt{Annotation}, which defines Java methods homonomous to the .NET attribute properties: any reference to such an annotation in the Java code will be translated into the corresponding .NET attribute when the application is converted to .NET. However, only read properties are supported, even if the original .NET attribute properties were read/write.}
\end{itemize}

%-----------------------------------------------------------------------
\section{\tuprolog.NET now}
\label{sec:dotnet-tuprolog-now}
%-----------------------------------------------------------------------

The management difficulties in keeping coherent two such evolving projects (the Java and the .NET versions) indicated that the approach of a separate development was not sustainable in the perspective.
This led to a complete strategic change, resulted into the adoption of the IKVM \cite{ikvm} bytecode translator as a tool to automate the generation of \tuprolog.NET \textit{from the same Java bytecode} (other than sources) as the Java version, which could then become the only one to be actively maintained ``by hand''.

Despite some (minor) performance issues (the IKVM-generated \tuprolog{} version appears 15\% slower, in the average, than its Java counterpart), the approach turned out to be winning, enabling the two platforms to converge for all they have in common---namely, everything other than the \textit{CLILibrary} and the .NET-specific issues.

%--------------------------------------------
\subsection{Highlights}
\label{ssec:dotnet-highligths}
%--------------------------------------------

\tuprolog{}.NET 2.5 builds on top of the winning idea of version 2.2 (language conventions for multi-language interoperability with Prolog), but goes farther by exploiting the value-added brought by the IKVM approach: the chance to use \textit{even Java} as if it were directly available on the .NET platform.
%
This extra value spreads into several directions:
\begin{itemize}
  \item .NET objects can be accessed, in addition to Java objects, via       \textit{OOLibrary} -- the renovated version of JavaLibrary -- from \tuprolog{};

  \item .NET applications can be developed (instead of Java applications, which obviously require the \tuprolog{} Java version) that exploit \tuprolog{} as a third-party library, with the only difference that a \texttt{dll} assembly is to be referenced by the (Visual Studio) project, instead of a JAR archive;

  \item the whole P@J framework for implementing Java methods in Prolog remains available, and takes a newer form in the .NET context;

  \item \tuprolog{} libraries can be written in Java, as well as in other .NET languages, resulting into a \texttt{dll} assembly in the end;

  \item Java can be used together with C\#, F\#, and other .NET languages in the same .NET application, where \tuprolog{} can possibly play the role of the director (orchestrator, coordinator) in-front-of or behind the scenes.
\end{itemize}

\noindent In the next Sections of this Chapter, these dimensions are discussed and explored, roughly following the same structure as Chapter \ref{ch:mpp-in-java}.

\begin{table}
{\small
\begin{tabular}{|p{2cm}|p{2cm}|p{2.4cm}|p{2cm}|p{2.2cm}|}
\hline
  Benchmark & Java direct & Java via Prolog & C\# direct & C\# via Prolog\\
  Math   & 118 & 182 & 116 & 118\\
  Concat & 185 & 211 & 162 & 161\\
  Sort   & 147 & 149 & 142 & 143\\
  \hline
\end{tabular}}
  \caption{Performance comparison between Java and C\# code executed directly or via \tuprolog{}.NET (times in milliseconds).}\label{tab:dotnet-benchmarks}
\end{table}

From the performance viewpoint, it is already known from the experience of the older \tuprolog{}.NET 2.2 (see Section \ref{ssec:dotnet-tuprolog2.2}) that an overhead is to be expected on Java applications.
To quantify it in some common situations, Table \ref{tab:dotnet-benchmarks} shows the average execution times of three micro-benchmarks (\textit{math}, \textit{concat} and \textit{sort}) when written in Java and C\#, executed directly and via \tuprolog{}.NET, respectively: \textit{math} performs algebraic operations on real numbers, \textit{concat} concatenates strings via the \texttt{StringBuilder} class available in both languages, and \textit{sort} sorts an array of integer numbers via quicksort.

Quite clearly, the execution of Java code via IKVM introduces an overhead\footnote{These figures are not very sensitive to the time overhead of class loading, because the classes to be loaded here are few and small: however, the first iterations of the test program do show higher execution times for this reason.} whose weight depends of the specific operation area, and whose cause is mainly the IKVM implementation of Java libraries: in fact, the \textit{sort} test, where IKVM incorporates its own implementation of the Java library instead of using the default one, is not affected in its performance.

Conversely, the execution of .NET code (the implementation language selected is irrelevant for this comparison) is basically overhead-free even when triggered from \tuprolog{}.

%-----------------------------------------------------------------------
\section{Using .NET from Prolog: OOLibrary}
\label{sec:dotnet-oolibrary}
%-----------------------------------------------------------------------

\subsubsection{Motivation}

Since \tuprolog{}.NET is automatically generated from the Java sources via IKVM, JavaLibrary is also available for free; however, since this library was designed for Java, it inherently supports Java concepts and constructs, but is obviously unaware of the features that are specific to .NET languages, such as properties, delegates, etc.
%
So, while .NET objects could be loaded and exploited via JavaLibrary ``as is'' (thanks to the extended semantics of \texttt{Class.forName} discussed in Section \ref{ssec:ikvm-class-loading}), their support would be imperfect, for three main reasons:
\begin{itemize}
  \item the lack of support for some .NET language constructs;
  \item the different Java naming convention for methods w.r.t. Java;
  \item the code reorganization performed behind-the-scenes by the .NET compilers, which sometimes change the names of syntactic elements---for instance, properties are compiled by adding a pair of getter/setter methods.
\end{itemize}

\noindent These aspects are put well in evidence by the example below, which refers to a class \texttt{Student} (written in C\#) defining a ``standard'' student with some ``obvious'' properties:

\begin{verbatim}
    java_object('CStudent.Student, CStudent',
                [123456,'John','Smith'], Obj),
    Obj <- 'PrintStudent' returns Value,
    Obj <- 'get_Name' returns Value,
    Obj <- 'set_Name'('Albert').
\end{verbatim}

\noindent As the first line shows, a \texttt{Student} instance can be created via \texttt{java\_object/3} \textit{as if it were a Java class}, but only by means of its \texttt{\textit{AssemblyQualifiedName}}---possibly specifying also its version, culture and public key.
Moreover, the method name must be quoted, since the .NET conventions require the first letter to be capitalized.
Last but not least, access to properties -- that the translated JavaLibrary does not know  as such -- must be mediated by the get/set methods added by the .NET compiler, with a loss both of expressiveness (the \texttt{Obj.Property} notation is lost) and of transparency (the compiler transformations must be known to bypass the problem).

This is why the direct use of JavaLibrary is \textit{deprecated} in \tuprolog{}.NET, which provides a better alternative: \textit{OOLibrary}.

OOLibrary extends JavaLibrary by enabling \tuprolog{}.NET to interact with both Java and .NET software components. In principle, any .NET language can be supported, although the current distribution includes the support only for the most widely used .NET languages (C\#, F\# and VB.NET), other than Java itself; however, the support for other .NET languages can be easily added, by defining further \textit{language conventions}.

\subsubsection{Language Conventions}

Language conventions are \tuprolog{} means to separate and embed the language-specific aspects from the library core: originally introduced in \tuprolog{}.NET 2.2 (see Section \ref{ssec:dotnet-tuprolog2.2} above), they work as a bridge between the language-specific naming issues and the underlying Java-based machinery.

Conventions define standard methods (Table \ref{tab:dotnet-convention-interface}) that express how the name of the required entity (class, method, property, public field, etc) must be modified to take into account the compiler modifications, so that the original .NET name may be transparently used in a \tuprolog{} program.
%
\begin{table}
{\small
\begin{verbatim}
public abstract class Convention{
  public abstract string Name ...
  public virtual string GetNamespace(string oldNamespace) ...
  public virtual string GetClassName(string oldClassName) ...
  public virtual string GetMemberName(string oldMemberName) ...
  public virtual string GetFieldName(string oldFieldName) ...
  public virtual string GetPropertyGetterName(string oldPropName) ...
  public virtual string GetPropertySetterName(string oldPropName) ...
  public virtual bool IsArrayClass(string className)...
  public static Convention LoadConvention(string assembly,
                                          string className)...
}
\end{verbatim}
}
\caption{The public interface of the root \texttt{Convention} class. Any actual convention for a given language must specialize from this class according to the language details.}
\label{tab:dotnet-convention-interface}
\end{table}
%
Obviously, the \texttt{GetXX} methods convert the name of the corresponding entity, while \texttt{IsArrayClass} checks whether the class represents an array---typically verifying if its name ends with \texttt{"[]"}, but this behavior can be redefined if a language adopts a different naming scheme.
The abstract \texttt{Name} property represents the name of the convention: each actual convention will set it to the corresponding language (i.e., \texttt{"csharp"}, \texttt{"fsharp"}, etc.)

Currently, four conventions are included in the distribution:
\begin{itemize}
  \item \textbf{C\#}: in this language all the names, except for field names, must start with a capital letter: so the \texttt{GetXX} methods must change the letter case accordingly. Moreover, since properties are compiled in a pair of \texttt{get\_}/\texttt{set\_} methods, the two \texttt{GetPropertyGetterMethod} and \texttt{GetPropertySetterMethod} methods return strings like \texttt{get\_\textit{PropName}} / \texttt{set\_\textit{PropName}}, respectively.

  \item \textbf{F\#}: this convention is identical to C\#'s.

  \item \textbf{VB.NET}: this convention is identical to C\#'s, except for arrays, that are defined through \texttt{()} in Visual Basic .NET instead of \texttt{[]}: so, the \texttt{IsArrayClass} method is redefined accordingly.

  \item \textbf{Java} this convention operates opposite to the above, changing method and field names so that they start with a lowercase letter; class names are checked for starting with an uppercase letter, and packages are changed to all-lowercase.
\end{itemize}

\noindent Since conventions and OOLibrary are part of \tuprolog{}.NET only, they are both implemented in C\#, to avoid unnecessary intermediate conversions.

\subsubsection{OOLibrary: predicates}

OOLibrary puts together the easy of use and immediateness of JavaLibrary with the convention-based inspiration of the former \textit{CLILibrary} (found in version 2.2): Table \ref{tab:dotnet-oolibrary-interface} lists its predicates.
%
\begin{table}
{\small
\begin{verbatim}
public class OOLibrary {
  public bool new_object_4(Term conventionName, Term className,
                           Term args, Term objRef)
  public bool destroy_object_1(Term objRef)
  public bool method_call_3(Term objRef, Term methodName, Term resRef)
  public bool load_convention_3(Term assemblyName,
                                Term conventionName, Term convRef)
  public bool dload_convention_3(Term assemblyName,
                                Term conventionName, Term convRef)
  public bool unload_convention_1(Term convRef)
}
\end{verbatim}
}\caption{The public interface of the \texttt{OOLibrary} class. In addition, the \texttt{$<-$/2}, (\texttt{$<-$},\texttt{returns})\texttt{/3} and \texttt{.} operators are defined for method calling and field/property access with the \texttt{get}/\texttt{set} pseudo-methods, exactly as in JavaLibrary.}
\label{tab:dotnet-oolibrary-interface}
\end{table}

\noindent These methods modify the names of the received entities according to the specified convention, then call the corresponding JavaLibrary methods.
For instance, if the target object is written in C\#, OOLibrary:
\begin{itemize}
  \item retrieves the associated convention (if any);
  \item changes the method name accordingly;
  \item invokes \texttt{java\_call\_3} to perform the operation.
\end{itemize}

\noindent The \texttt{dload\_convention\_3} method is the directive version of \texttt{load\_convention\_3}), the difference being in the lifetime of the loaded convention: the directive loads a convention for the whole life of the current \tuprolog{} engine, while the standard version loads it for the duration of the current query only.

%-------------------------------------
\subsection{Examples}
\label{sec:dotnet-oolibrary-examples}
%-------------------------------------

To show OOLibrary at work, the \texttt{Student} class (already cited in Section \ref{sec:dotnet-oolibrary}) has been rewritten in all the four supported languages:
Tables \ref{tab:dotnet-oolibrary-examples1} shows how it can be exploited from \tuprolog{}.NET in Visual Basic (top two examples) and Java (bottom two examples), with and without conventions, while Table \ref{tab:dotnet-oolibrary-examples2} shows a comprehensive example where all the four supported .NET languages are used at the same time by the same \tuprolog{} program.

\begin{table}
{\small
\begin{verbatim}
visualbasicWithoutConvention :-
  new_object('VBStudent.Student',[123456,'john','smith'], Obj),
  Obj <- 'PrintStudent' returns Student,
  Obj <- get_Id returns StudentNumber,
  class('VBStudent.Student,VBStudent') <- get_StaticProperty returns Value,
  new_object('VBStudent.Student, VBStudent[]',[10], Array).
  
visualbasicWithConvention :-
  load_convention('VBConvention.dll','VBConvention.VBDotNet',Conv),
  new_object(Conv,'VBStudent.Student, VBStudent',
                                     [123456,'john','smith'], Obj),
  Obj <- printStudent returns Student,
  Obj.id <- get(StudentNumber),
  class('VBStudent.Student, VBStudent').staticProperty <- get(Value),
  new_object(Conv, 'VBStudent.Student, VBStudent()',[10], Array).
  
javaWithoutConvention :-
  new_object('javastudent.Student',[123456,'john','smith'], Obj),
  Obj <- printStudent returns Student,
  Obj <- getId returns StudentNumber,
  class('javastudent.Student') <- printInfoUniv returns University,
  new_object('javastudent.Student[]',[10], Array).

javaWithConvention :-
  load_convention('JavaConvention.dll','JavaConvention.Java',Conv),
  new_object('javastudent.Student',[123456,'john','smith'], Obj),
  Obj <- 'PrintStudent' returns Student,
  Obj <- getId returns StudentNumbers,
  class('javastudent.Student') <- printInfoUniv returns University,
  new_object('javastudent.Student[]',[10], Array).
\end{verbatim}
}
  \caption{Using the \texttt{Student} class in Visual Basic and Java without / with conventions. }
  \label{tab:dotnet-oolibrary-examples1}
\end{table}

\noindent Without conventions (Table \ref{tab:dotnet-oolibrary-examples1}), syntax is heavier and less natural from the viewpoint of the language considered.
In the first example, for instance, \textit{i)} method names must be quoted because of their capital initial, \textit{ii)} accessing a property means to know the corresponding method name (\texttt{get\_Id}), and \textit{iii)} array creation calls for an ``absurd'' (from the VB.NET viewpoint) \texttt{[]} suffix instead of the \texttt{()} used in that language for that purpose.
Using the VB convention, instead, method quoting is no longer necessary, property access can be made in a straightforward way (\texttt{Object.Property} notation), and array .creation adheres to the Visual Basic syntax rules

Similar considerations apply to Java objects, too: in this case, either the Java class is translated in .NET statically (in which case the corresponding \texttt{dll} will be available in the file system), or the Java \texttt{.class} file is kept ``as is'', and is loaded and converted dynamically by IKVM when needed\footnote{via the \texttt{ClassPathAssemblyClassLoader} (Section \ref{ssec:ikvm-class-loading}).}
In this case the convention is perhaps less necessary, since the naming changes imposed by the language style are minimal; yet, the convention makes it possible to write method names with the lowercase initial, which makes the Prolog writing lighter.


\begin{table}
{\footnotesize
\begin{verbatim}
sumAllExams(TotExams) :-
 load_convention('CSharpConvention.dll','CSharpConvention.CSharp',CSConv),
 load_convention('FSharpConvention.dll','FSharpConvention.FSharp',FSConv),
 load_convention('VBConvention.dll',    'VBConvention.VBDotNet',  VBConv),
 load_convention('JavaConvention.dll',  'JavaConvention.Java',    JConv),

 new_object(CSConv, 'CStudent.Student, CStudent',[122345,'john',''], StudCS),
 new_object(FSConv, 'FStudent.Student, FStudent',[525718,'Mary',''], StudFs),
 new_object(VBConv, 'VBStudent.Student, VBStudent',[987650,'Jean',''], StudVB),
 new_object(JConv,  'javastudent.Student',[476328,'Holly',''], StudJa),

 StudCS.exams <- get(Ex1),
 StudFs.exams <- get(Ex2),
 StudVB.exams <- get(Ex3),
 StudJa <- getExams returns Ex4,

 TotExams is Ex1 + Ex2 + Ex3 + Ex4.
\end{verbatim}
}
  \caption{Using four \texttt{Student} classes written in four languages.}
  \label{tab:dotnet-oolibrary-examples2}
\end{table}

Table \ref{tab:dotnet-oolibrary-examples1}) shows an example where \tuprolog{} instantiates and exploits objects written in multiple languages, \textit{maintaining the interoperability between Prolog primitive types (string, numbers, etc) and the primitive types of the .NET and Java languages}.
In fact, values in the Prolog variables \texttt{Ex1}, \texttt{Ex2}, \texttt{Ex3} and \texttt{Ex4} are summed directly, with no explicit conversions.

Interoperability between .NET and Java classes becomes a problem, instead, when complex types (i.e., anything other than primitive types) are involved in the same \tuprolog{} program, because a Java object, possibly returned from a Java method, cannot be passed to a .NET instance ``as is'', and no automatic conversion occurs.
%
The typical workaround to this problem is to transform the problematic data in suitable Prolog strings that constitute a valid \tuprolog{} representation of a value of a Prolog type (and viceversa), thus exploiting \tuprolog{} as a mediator (both as a component and as a language) to overcome the incommunicability.
%
This issue is covered more in detail in Section \ref{sec:dotnet-putting-together} below.


%-----------------------------------------------------------------------
\section{Using Prolog from .NET: the API}
\label{sec:dotnet-oo-api}
%-----------------------------------------------------------------------

Since \tuprolog{}.NET is automatically generated from the Java sources via IKVM, the available API is the same presented in Section \ref{sec:java-api}.
%
To create a .NET application using \tuprolog{}, do the following:\footnote{The example is taken from the degree thesis in Computer Engineering of Alessandro Montanari, Universit\`{a} di Bologna, 2010.}

\begin{enumerate}
  \item open the IDE of your choice (we refer to Microsoft Visual Studio 2010);
  \item create a new project (in our case, from the \textit{File} menu, select \textit{New > Project}), select the proper language (in this case, \textit{Visual C\#} from the left panel), the proper application type (here, \textit{Windows Forms Application}), and digit the application name and file position (Figure \ref{fig:dotnet-visualstudio1}, \textit{top});
  \item add a reference to the \tuprolog{}.NET assembly, \texttt{tuprolog.dll} (in this case, right-click on \textit{References} in the \textit{Solution Explorer} panel, click on \textit{Add References}, browse the file system up to the assembly and select it---Figure \ref{fig:dotnet-visualstudio1}, \textit{bottom});
  \item add a reference to the \texttt{IKVM.OpenJdk.Core.dll} assembly that contains the IKVM implementation of Java packages, following the same procedure;
  \item now write/draw your .NET application (in this case, we draw the user interface shown in Figure \ref{fig:dotnet-visualstudio3} (\textit{top}) and write the implementation of the \textit{OK} button \ref{fig:dotnet-visualstudio4}); the final result (an application for the symbolic derivative of a function, where Prolog takes care of the symbolic calculus and .NET of the GUI) is shown in Figure \ref{fig:dotnet-visualstudio3} (\textit{bottom}).
\end{enumerate}

\begin{figure}
  \includegraphics[width=12cm]{images/dotnet-visualstudio1}\\
  \includegraphics[width=12cm]{images/dotnet-visualstudio2}
  \caption{Creating a .NET application using \tuprolog{} in Visual Studio: new project.}\label{fig:dotnet-visualstudio1}
\end{figure}

\begin{figure}
  \includegraphics[width=12cm]{images/dotnet-visualstudio3}\\
  \includegraphics[width=12cm]{images/dotnet-visualstudio5}
  \caption{Creating a .NET application using \tuprolog{} in Visual Studio: the user GUI}\label{fig:dotnet-visualstudio3}
\end{figure}

\begin{figure}
  \includegraphics[width=12cm]{images/dotnet-visualstudio4}
  \caption{Creating a .NET application using \tuprolog{} in Visual Studio: the .NET handler of the \textit{OK} button.}\label{fig:dotnet-visualstudio4}
\end{figure}


%-----------------------------------------------------------------------
\section{Augmenting Prolog via .NET: developing new libraries}
\label{sec:dotnet-developing new libraries}
%-----------------------------------------------------------------------

New \tuprolog{}.NET libraries can be written in any of the .NET languages, and then compiled normally via Microsoft Visual Studio; alternatively, libraries written in Java can be used, by translating them in .NET via IKVM (if they are not part of the standard \tuprolog{} distribution, of course).

The approach is the basically same presented in Section \ref{sec:howto-develop-libraries}: the only difference concerns how libraries are located in the file system, which obviously adheres to the .NET conventions\footnote{
\texttt{http://msdn.microsoft.com/en-us/library/yx7xezcf.aspx}}.
Accordingly, the configuration file \texttt{2p.exe.config} specifies the custom paths where the library probing must take place: currently, the \texttt{lib} folder is included, so as to provide a standard place where to put any third-party library.
 
If Java classes are also used (\texttt{.class} or \texttt{.jar}), these must be in the same folder as the \texttt{2p.exe} executable (subdirectories are not acceptable).

%-----------------------------------------------------------------------
\section{Augmenting .NET via Prolog:\\the P@J framework.. revised}
\label{sec:dotnet-pj}
%-----------------------------------------------------------------------

Since \tuprolog{}.NET is automatically generated from the Java sources via IKVM, the P@J framework presented in Section \ref{sec:p@j} is also available.
%
However, its support in .NET is currently partial:
\begin{itemize}
  \item a Java application using P@J, translated to .NET via IKVM, works normally in .NET;
  \item instead, a .NET application trying to use P@J via .NET attributes (the .NET counterpart of Java annotations) currently fails, since the Javassist tool raises exception.
\end{itemize}

\noindent A different, more .NET specific, approach is currently under study and will be included in a future \tuprolog{}.NET version.

%-----------------------------------------------------------------------
\section{Putting everything together}
\label{sec:dotnet-putting-together}
%-----------------------------------------------------------------------

As anticipated in Section \ref{sec:dotnet-oolibrary-examples}, interoperability between .NET and Java classes occurs transparently via \tuprolog{}.NET only as long as primitive data types are involved; a problem occurs, instead, when complex types (like lists, arrays, etc.) are asked to cooperate in the same \tuprolog{} program, because a Java object, possibly returned from a Java method, cannot be passed to a .NET instance ``as is'' (and vice-versa), and no automatic conversion occurs.
The typical workaround to this problem is to transform the problematic data in suitable Prolog strings that constitute a valid \tuprolog{} representation of a value of a Prolog type (and viceversa), exploiting \tuprolog{} as a mediator (both as a component and as a language) to overcome the incommunicability.

Suppose, for instance, that two libraries -- one written in Java, the other in some .NET language -- are to be used together in some application.
To exploit \tuprolog{}.NET as a mediator, the critical data to be exchanged must be first serialized into suitable Prolog strings, and then converted into Prolog terms that become the \textit{lingua franca} for data exchange.
The reason for choosing a string based representation is that, beyond its easy applicability to virtually any data type, it can exploit the \texttt{text\_term/2} predicate (which transforms a Prolog term into its textual representation according to pre-defined rules, and viceversa) for speeding up the job and/or perform other intermediate transformations.

These adapter functions can be either encapsulated in the libraries, if their source is available and can be modified, or be put in some \textit{ad hoc} converter classes (Java / .NET depending on the situation), or even be performed directly in Prolog, if the conversion can be more conveniently done in this way.

\begin{figure}
   \centering
  \includegraphics[width=7cm]{images/dotnet-pipolo1}
  \caption{Using \tuprolog{}.NET to bridge between classes using heterogeneous data types.}\label{fig:dotnet-pipolo1}
\end{figure}

Figure \ref{fig:dotnet-pipolo1} shows this kind of situation: class \texttt{A} exposes the \texttt{GetMyList} method that return an instance of \texttt{MyList}, while class \texttt{B} provides a \texttt{PrintList} method that accepts a \texttt{List} instance (not a \texttt{MyList}, then).
Using \tuprolog{} as a mediator/adapter means \textit{a)} to develop the required pair of serialize/deserialize methods, and \textit{b)} exploit \tuprolog{} to bridge class A and B via such methods.
In this case, \texttt{MyListToString} and \texttt{StringToList} are needed to convert \texttt{MyList} to string, and string to \texttt{List}, respectively.
%
If both classes \texttt{A} and \texttt{B} are .NET classes, the best option is probably to implement them as static operations of a third \texttt{Converter} .NET class; if, instead, the two classes belong to different platforms, two different converter classes need to be set up---one in Java, to host \texttt{MyListToString}, and one in .NET, to host \texttt{StringToList}.

The resulting Prolog code would them be something like this:
\begin{verbatim}
    ...
    A <- GetMyList returns MyList,
    Converter1 <- MyListToString(MyList) returns MyListAsText,
    % any intermediate transformation
    Converter2 <- StringToList(ListAsText) returns List,
    B <- PrintList(List),
    ...
\end{verbatim}


%----------------------------------------------
\subsection{Example: Multi-language TicTacToe}
\label{ssec:mpp-tictactoe}
%----------------------------------------------


Questo esempio di utilizzo è stato realizzato per mostrare:
"	il problema dello scambio di dati .NET/Prolog;
"	un possibile refactoring in senso multi-paradigma di una applicazione esistente;
Per questo è stato realizzato il programma in più parti, partendo da un'applicazione esistente (15) implementata unicamente nel linguaggio Prolog. È stato quindi effettuato un refactoring multi-paradigma dell'applicazione, utilizzando il linguaggio più opportuno per ognuno dei compiti da svolgere: ad esempio, in Prolog è realizzata la logica di generazione delle mosse del computer mentre C\#(o uno degli altri linguaggi .NET) viene usato per la logica di gestione dell'I/O e del modello dei dati.

L'applicazione consiste in un eseguibile .NET (file tictactoe.exe) che funziona da punto di ingresso, un sorgente Prolog (file tictac.pl) e una classe (classe TicTacToe), la classe TicTacToe è stata realizzata in più versioni, una per ogni linguaggio supportato (C\#, VB.NET, F\# e Java).

Il codice Prolog utilizzato è stato quindi modificato in modo da avere solo due responsabilità: la gestione del ciclo principale di esecuzione e la generazione delle mosse del computer.  I predicati che svolgono funzioni ora implementate dalla classe TicTacToe sono stati modificati in modo da far uso dei metodi offerti dalla classe, semplificando così il codice Prolog.
Classe TicTacToe
La classe TicTacToe è stata implementata in più versioni, realizzando ciascuna in un linguaggio diverso pur presentando la stessa interfaccia: questo rende le diverse classi intercambiabili. Il codice Prolog può usare in modo trasparente la classe TicTacToe indipendentemente dal linguaggio in cui è stata realizzata.
La classe ha i seguenti obiettivi:
-	mantenere una rappresentazione del modello dei dati;
-	fornire alcuni metodi per operazioni sul modello;
-	fornire metodi per eseguire I/O.
In particolare, la classe, implementata nel linguaggio C\#, espone la seguente interfaccia:


Le funzioni di ognuno dei metodi e proprietà esposti sono:
-	proprietà Caselle: restituisce un array di char che rappresenta lo stato attuale della tavola di gioco. Ogni elemento rappresenta una casella, i valori che può assumere durante l'uso sono: 'x', 'o' oppure un numero da 1 a 9 che indica di quale casella si tratti se non è stata occupata da un giocatore;
-	proprietà Remaining: restituisce il numero di caselle libere rimanenti;
-	proprietà Board: restituisce una stringa che rappresenta lo stato attuale della tavola di gioco. Questa proprietà realizza la conversione dell'array rappresentante la tavola di gioco in un termine Prolog, in particolare restituisce una stringa in un formato che è interpretabile da Prolog dopo la sua conversione (attraverso il predicato text\_term/2). Il formato utilizzato per la rappresentazione in Prolog è il seguente: 'board(\_,x,o,x,\_,\_,\_,o,x)'; questa struttura rappresenta la tavola di gioco secondo il formato usato da tictac.pl per generare le mosse del computer, le caselle vuote vengono indicate con la variabile any, per quelle occupate viene invece usato un atomo, x oppure o, che indica il segnalino usato;
"	metodo Gioca: riceve in ingresso il numero della casella (da 1 a 9) e una stringa contenente un carattere che indica il giocatore ('x' oppure 'o'). Si è scelto di usare una stringa come input poiché gli atomi Prolog, come già visto nel terzo capitolo, vengono mappati da tuProlog in istanze della classe String, anche se questi ultimi hanno la lunghezza di un solo carattere;
"	metodo CheckWin: questo metodo, una volta invocato, restituisce un numero intero che indica se uno dei due giocatori ha vinto. Viene restituito 1 in caso di vittoria delle 'x', 2 per la vittoria delle 'o', 0 in caso non ci sia una vittoria;
"	metodo PrintBoard: metodo che stampa su standard output una rappresentazione della tavola di gioco;
"	metodi InputResponse, InputPlayer, InputMove: metodi usati per ricevere in input dati dall'utente;
Tutte le versioni della classe TicTacToe implementano questa interfaccia, fa eccezione la versione Java, in cui le proprietà (non supportate dal linguaggio) sono sostituite da dei normali metodi che offrono le stesse funzionalità. Questa differenza viene gestita in Prolog mediante la definizione di predicati multipli; quando un predicato viene invocato, l'interprete eseguirà in sequenza tutte le implementazioni finché una di esse non ha successo. Questo permette di usare oggetti Java e .NET in maniera trasparente da Prolog.

File tictac.pl
Il file contenente il codice Prolog dell'applicazione. In seguito al refactoring questa parte ha i seguenti obiettivi:
"	gestire la classe TicTacToe e utilizzare le funzionalità offerte da essa;
"	generare le mosse del giocatore controllato dal computer.
Di seguito è riportata una figura che illustra la struttura del programma originale, suddividendone i predicati in gruppi: a fianco di questi viene indicato come sono stati modificati i predicati nella nuova versione del codice Prolog. Le modifiche sono evidenziate in grassetto.

Per gestire la differenza tra le classi TicTacToe realizzate in linguaggi .NET e quella in Java sono state aggiunte delle coppie di predicati usate per accedere alle proprietà, nel caso di classi .NET, o ai metodi equivalenti, nel caso di Java. Questi predicati sono get\_board e get\_remaining.
Per ricavare lo stato della tavola di gioco viene usato il predicato get\_board. Il predicato si occupa anche di convertire la stringa ottenuta in un termine Prolog che possa essere interpretato direttamente, questo mediante l'uso del predicato text\_term fornito da tuProlog. Il predicato get\_remaining permette di ricavare il numero di caselle libere.
Per l'avvio dell'applicazione sono stati realizzati quattro predicati che vengono eseguiti prima del predicato go, originariamente usato per l'avvio del programma.
loadgameCS, loadgameVB, loadgameFS, loadgameJava.
Ognuno di questi predicati avvia l'applicazione, con la differenza che viene caricata e utilizzata la classe TicTacToe del relativo linguaggio. Viene quindi caricata la Convenzione relativa al linguaggio scelto e istanziata la classe TicTacToe, contenuta nella variabile Game che viene mantenuta per la durata della partita. Per istanziare la classe TicTacToe viene specificato il nome come 'namespace.nomeClasse, nomeAssembly', viene usato inoltre un costruttore privo di argomenti in ingresso, per cui nel predicato si fornisce una lista Prolog vuota '[]'. Per il linguaggio Java il nome viene specificato diversamente, in questo caso viene indicato solamente come 'nomePackage.nomeClasse'.
Il programma inizia (predicato go) stampando a schermo le istruzioni del gioco, chiedendo al giocatore quale segnalino vuole utilizzare ('x' oppure 'o') e se vuole essere il primo a compiere la mossa o meno.

Il predicato play realizza il ciclo principale dell'applicazione. Le variabili Player e PlayerMoves indicano, rispettivamente, il segnalino scelto dal giocatore "umano" e se è o meno il turno del giocatore "umano" (contiene 'yes' se lo è, 'no' altrimenti).
Il predicato oneMove è implementato due volte, una nel caso sia il giocatore umano ad effettuare la mossa e l'altra nel caso sia il computer. In questo predicato viene usato get\_board per ottenere la rappresentazione Prolog della tavola di gioco; questo formato viene infatti usato dal predicato generateMove, che valuta la tavola di gioco per decidere la prossima mossa del computer.
Il predicato makeMove viene usato per effettuare una mossa, fa uso infatti del metodo Gioca esposto dalla classe TicTacToe e quindi stampa lo stato della tavola usando il metodo PrintBoard.
Il predicato continuePlay, controlla che ci sia stata o meno una vittoria o un pareggio e, in caso negativo, esegue nuovamente il predicato play con il turno del prossimo giocatore.
Il resto del codice Prolog riguarda principalmente la generazione delle mosse del computer, questa parte è rimasta invariata rispetto all'originale in quanto la struttura dati che viene fornita in ingresso è quella ricavata dalla proprietà Board della classe TicTacToe.


File tictactoe.exe
L'eseguibile utilizzato come punto di ingresso dell'applicazione è stato realizzato in C\#, espone il seguente metodo Main in cui viene caricato il sorgente Prolog e configurato correttamente il motore Prolog caricando la OOLibrary.

Per visualizzare correttamente l'output effettuato dal codice Prolog viene usato il seguente OutputListener, che ridirige semplicemente tutto l'output sulla Console:

public class MyOutputListener : OutputListener
{
public void onOutput(OutputEvent e)
{
System.Console.Write(e.getMsg());
}
}

In questo esempio si è scelto di includere una proprietà che permettesse il passaggio del dato più complesso da scambiare: l'array contenente lo stato della tavola di gioco. Per il passaggio si è scelto di serializzarlo in una stringa e quindi convertirlo in un termine Prolog; il formato utilizzato, come già detto, è stato scelto poiché era già utilizzato dal codice Prolog per la generazione delle mosse, in questo modo non è stato necessario modificare i predicati che la attuano, che compongono gran parte del codice. Grazie a questo accorgimento, il resto dell'adattamento si è rivelato relativamente semplice e non ha presentato grossi ostacoli. Gli altri dati ottenuti dalla classe .NET sono, infatti, dei tipi primitivi che possono essere utilizzati direttamente da Prolog senza alcuna necessità di effettuare conversioni; ad esempio, il predicato get\_remaining restituisce una variabile Open contente un valore numerico, questo è utilizzabile direttamente da Prolog come si può vedere nell'implementazione del predicato continuePlay.

L'esempio fa uso della conversione dei dati per scambiarle quelli che non sono direttamente compatibili: l'array contenuto nella classe TicTacToe viene infatti convertito in una stringa piuttosto che scambiato come oggetto .NET. Questo approccio si è rivelato essere il migliore in questo caso, poiché si è desiderato utilizzare del codice Prolog preesistente basato su una determinata rappresentazione della tavola da gioco, così facendo si è potuto mantenere gran parte del codice senza doverlo modificare. La conversione avviene solo da .NET (o Java) a Prolog: se fosse necessario restituire lo stato della tavola di gioco dopo averla modificata da Prolog, sarebbe stato sufficiente implementare un ulteriore metodo che convertisse il termine Prolog in un array per .NET o Java.
Un approccio che in questo caso si sarebbe rivelato più efficiente è quello di realizzare una libreria separata che offra le funzioni di serializzazione e deserializzazione dei dati; in questo modo si eviterebbe di implementare le stesse funzioni più volte.

